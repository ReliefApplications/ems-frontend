{"ast":null,"code":"import { Trie } from '@wry/trie';\nexport { Trie as KeyTrie } from '@wry/trie';\nimport { Slot } from '@wry/context';\nexport { asyncFromGen, bind as bindContext, noContext, setTimeout } from '@wry/context';\n\nfunction defaultDispose() {}\n\nvar Cache =\n/** @class */\nfunction () {\n  function Cache(max, dispose) {\n    if (max === void 0) {\n      max = Infinity;\n    }\n\n    if (dispose === void 0) {\n      dispose = defaultDispose;\n    }\n\n    this.max = max;\n    this.dispose = dispose;\n    this.map = new Map();\n    this.newest = null;\n    this.oldest = null;\n  }\n\n  Cache.prototype.has = function (key) {\n    return this.map.has(key);\n  };\n\n  Cache.prototype.get = function (key) {\n    var node = this.getNode(key);\n    return node && node.value;\n  };\n\n  Cache.prototype.getNode = function (key) {\n    var node = this.map.get(key);\n\n    if (node && node !== this.newest) {\n      var older = node.older,\n          newer = node.newer;\n\n      if (newer) {\n        newer.older = older;\n      }\n\n      if (older) {\n        older.newer = newer;\n      }\n\n      node.older = this.newest;\n      node.older.newer = node;\n      node.newer = null;\n      this.newest = node;\n\n      if (node === this.oldest) {\n        this.oldest = newer;\n      }\n    }\n\n    return node;\n  };\n\n  Cache.prototype.set = function (key, value) {\n    var node = this.getNode(key);\n\n    if (node) {\n      return node.value = value;\n    }\n\n    node = {\n      key: key,\n      value: value,\n      newer: null,\n      older: this.newest\n    };\n\n    if (this.newest) {\n      this.newest.newer = node;\n    }\n\n    this.newest = node;\n    this.oldest = this.oldest || node;\n    this.map.set(key, node);\n    return node.value;\n  };\n\n  Cache.prototype.clean = function () {\n    while (this.oldest && this.map.size > this.max) {\n      this.delete(this.oldest.key);\n    }\n  };\n\n  Cache.prototype.delete = function (key) {\n    var node = this.map.get(key);\n\n    if (node) {\n      if (node === this.newest) {\n        this.newest = node.older;\n      }\n\n      if (node === this.oldest) {\n        this.oldest = node.newer;\n      }\n\n      if (node.newer) {\n        node.newer.older = node.older;\n      }\n\n      if (node.older) {\n        node.older.newer = node.newer;\n      }\n\n      this.map.delete(key);\n      this.dispose(node.value, key);\n      return true;\n    }\n\n    return false;\n  };\n\n  return Cache;\n}();\n\nvar parentEntrySlot = new Slot();\n\nvar _a;\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar // This Array.from polyfill is restricted to working with Set<any> for now,\n// but we can improve the polyfill and add other input types, as needed. Note\n// that this fallback implementation will only be used if the host environment\n// does not support a native Array.from function. In most modern JS runtimes,\n// the toArray function exported here will be === Array.from.\ntoArray = (_a = Array.from, _a === void 0 ? function (collection) {\n  var array = [];\n  collection.forEach(function (item) {\n    return array.push(item);\n  });\n  return array;\n} : _a);\n\nfunction maybeUnsubscribe(entryOrDep) {\n  var unsubscribe = entryOrDep.unsubscribe;\n\n  if (typeof unsubscribe === \"function\") {\n    entryOrDep.unsubscribe = void 0;\n    unsubscribe();\n  }\n}\n\nvar emptySetPool = [];\nvar POOL_TARGET_SIZE = 100; // Since this package might be used browsers, we should avoid using the\n// Node built-in assert module.\n\nfunction assert(condition, optionalMessage) {\n  if (!condition) {\n    throw new Error(optionalMessage || \"assertion failure\");\n  }\n}\n\nfunction valueIs(a, b) {\n  var len = a.length;\n  return (// Unknown values are not equal to each other.\n    len > 0 && // Both values must be ordinary (or both exceptional) to be equal.\n    len === b.length && // The underlying value or exception must be the same.\n    a[len - 1] === b[len - 1]\n  );\n}\n\nfunction valueGet(value) {\n  switch (value.length) {\n    case 0:\n      throw new Error(\"unknown value\");\n\n    case 1:\n      return value[0];\n\n    case 2:\n      throw value[1];\n  }\n}\n\nfunction valueCopy(value) {\n  return value.slice(0);\n}\n\nvar Entry =\n/** @class */\nfunction () {\n  function Entry(fn) {\n    this.fn = fn;\n    this.parents = new Set();\n    this.childValues = new Map(); // When this Entry has children that are dirty, this property becomes\n    // a Set containing other Entry objects, borrowed from emptySetPool.\n    // When the set becomes empty, it gets recycled back to emptySetPool.\n\n    this.dirtyChildren = null;\n    this.dirty = true;\n    this.recomputing = false;\n    this.value = [];\n    this.deps = null;\n    ++Entry.count;\n  }\n\n  Entry.prototype.peek = function () {\n    if (this.value.length === 1 && !mightBeDirty(this)) {\n      rememberParent(this);\n      return this.value[0];\n    }\n  }; // This is the most important method of the Entry API, because it\n  // determines whether the cached this.value can be returned immediately,\n  // or must be recomputed. The overall performance of the caching system\n  // depends on the truth of the following observations: (1) this.dirty is\n  // usually false, (2) this.dirtyChildren is usually null/empty, and thus\n  // (3) valueGet(this.value) is usually returned without recomputation.\n\n\n  Entry.prototype.recompute = function (args) {\n    assert(!this.recomputing, \"already recomputing\");\n    rememberParent(this);\n    return mightBeDirty(this) ? reallyRecompute(this, args) : valueGet(this.value);\n  };\n\n  Entry.prototype.setDirty = function () {\n    if (this.dirty) return;\n    this.dirty = true;\n    this.value.length = 0;\n    reportDirty(this); // We can go ahead and unsubscribe here, since any further dirty\n    // notifications we receive will be redundant, and unsubscribing may\n    // free up some resources, e.g. file watchers.\n\n    maybeUnsubscribe(this);\n  };\n\n  Entry.prototype.dispose = function () {\n    var _this = this;\n\n    this.setDirty(); // Sever any dependency relationships with our own children, so those\n    // children don't retain this parent Entry in their child.parents sets,\n    // thereby preventing it from being fully garbage collected.\n\n    forgetChildren(this); // Because this entry has been kicked out of the cache (in index.js),\n    // we've lost the ability to find out if/when this entry becomes dirty,\n    // whether that happens through a subscription, because of a direct call\n    // to entry.setDirty(), or because one of its children becomes dirty.\n    // Because of this loss of future information, we have to assume the\n    // worst (that this entry might have become dirty very soon), so we must\n    // immediately mark this entry's parents as dirty. Normally we could\n    // just call entry.setDirty() rather than calling parent.setDirty() for\n    // each parent, but that would leave this entry in parent.childValues\n    // and parent.dirtyChildren, which would prevent the child from being\n    // truly forgotten.\n\n    eachParent(this, function (parent, child) {\n      parent.setDirty();\n      forgetChild(parent, _this);\n    });\n  };\n\n  Entry.prototype.forget = function () {\n    // The code that creates Entry objects in index.ts will replace this method\n    // with one that actually removes the Entry from the cache, which will also\n    // trigger the entry.dispose method.\n    this.dispose();\n  };\n\n  Entry.prototype.dependOn = function (dep) {\n    dep.add(this);\n\n    if (!this.deps) {\n      this.deps = emptySetPool.pop() || new Set();\n    }\n\n    this.deps.add(dep);\n  };\n\n  Entry.prototype.forgetDeps = function () {\n    var _this = this;\n\n    if (this.deps) {\n      toArray(this.deps).forEach(function (dep) {\n        return dep.delete(_this);\n      });\n      this.deps.clear();\n      emptySetPool.push(this.deps);\n      this.deps = null;\n    }\n  };\n\n  Entry.count = 0;\n  return Entry;\n}();\n\nfunction rememberParent(child) {\n  var parent = parentEntrySlot.getValue();\n\n  if (parent) {\n    child.parents.add(parent);\n\n    if (!parent.childValues.has(child)) {\n      parent.childValues.set(child, []);\n    }\n\n    if (mightBeDirty(child)) {\n      reportDirtyChild(parent, child);\n    } else {\n      reportCleanChild(parent, child);\n    }\n\n    return parent;\n  }\n}\n\nfunction reallyRecompute(entry, args) {\n  forgetChildren(entry); // Set entry as the parent entry while calling recomputeNewValue(entry).\n\n  parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);\n\n  if (maybeSubscribe(entry, args)) {\n    // If we successfully recomputed entry.value and did not fail to\n    // (re)subscribe, then this Entry is no longer explicitly dirty.\n    setClean(entry);\n  }\n\n  return valueGet(entry.value);\n}\n\nfunction recomputeNewValue(entry, args) {\n  entry.recomputing = true; // Set entry.value as unknown.\n\n  entry.value.length = 0;\n\n  try {\n    // If entry.fn succeeds, entry.value will become a normal Value.\n    entry.value[0] = entry.fn.apply(null, args);\n  } catch (e) {\n    // If entry.fn throws, entry.value will become exceptional.\n    entry.value[1] = e;\n  } // Either way, this line is always reached.\n\n\n  entry.recomputing = false;\n}\n\nfunction mightBeDirty(entry) {\n  return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);\n}\n\nfunction setClean(entry) {\n  entry.dirty = false;\n\n  if (mightBeDirty(entry)) {\n    // This Entry may still have dirty children, in which case we can't\n    // let our parents know we're clean just yet.\n    return;\n  }\n\n  reportClean(entry);\n}\n\nfunction reportDirty(child) {\n  eachParent(child, reportDirtyChild);\n}\n\nfunction reportClean(child) {\n  eachParent(child, reportCleanChild);\n}\n\nfunction eachParent(child, callback) {\n  var parentCount = child.parents.size;\n\n  if (parentCount) {\n    var parents = toArray(child.parents);\n\n    for (var i = 0; i < parentCount; ++i) {\n      callback(parents[i], child);\n    }\n  }\n} // Let a parent Entry know that one of its children may be dirty.\n\n\nfunction reportDirtyChild(parent, child) {\n  // Must have called rememberParent(child) before calling\n  // reportDirtyChild(parent, child).\n  assert(parent.childValues.has(child));\n  assert(mightBeDirty(child));\n  var parentWasClean = !mightBeDirty(parent);\n\n  if (!parent.dirtyChildren) {\n    parent.dirtyChildren = emptySetPool.pop() || new Set();\n  } else if (parent.dirtyChildren.has(child)) {\n    // If we already know this child is dirty, then we must have already\n    // informed our own parents that we are dirty, so we can terminate\n    // the recursion early.\n    return;\n  }\n\n  parent.dirtyChildren.add(child); // If parent was clean before, it just became (possibly) dirty (according to\n  // mightBeDirty), since we just added child to parent.dirtyChildren.\n\n  if (parentWasClean) {\n    reportDirty(parent);\n  }\n} // Let a parent Entry know that one of its children is no longer dirty.\n\n\nfunction reportCleanChild(parent, child) {\n  // Must have called rememberChild(child) before calling\n  // reportCleanChild(parent, child).\n  assert(parent.childValues.has(child));\n  assert(!mightBeDirty(child));\n  var childValue = parent.childValues.get(child);\n\n  if (childValue.length === 0) {\n    parent.childValues.set(child, valueCopy(child.value));\n  } else if (!valueIs(childValue, child.value)) {\n    parent.setDirty();\n  }\n\n  removeDirtyChild(parent, child);\n\n  if (mightBeDirty(parent)) {\n    return;\n  }\n\n  reportClean(parent);\n}\n\nfunction removeDirtyChild(parent, child) {\n  var dc = parent.dirtyChildren;\n\n  if (dc) {\n    dc.delete(child);\n\n    if (dc.size === 0) {\n      if (emptySetPool.length < POOL_TARGET_SIZE) {\n        emptySetPool.push(dc);\n      }\n\n      parent.dirtyChildren = null;\n    }\n  }\n} // Removes all children from this entry and returns an array of the\n// removed children.\n\n\nfunction forgetChildren(parent) {\n  if (parent.childValues.size > 0) {\n    parent.childValues.forEach(function (_value, child) {\n      forgetChild(parent, child);\n    });\n  } // Remove this parent Entry from any sets to which it was added by the\n  // addToSet method.\n\n\n  parent.forgetDeps(); // After we forget all our children, this.dirtyChildren must be empty\n  // and therefore must have been reset to null.\n\n  assert(parent.dirtyChildren === null);\n}\n\nfunction forgetChild(parent, child) {\n  child.parents.delete(parent);\n  parent.childValues.delete(child);\n  removeDirtyChild(parent, child);\n}\n\nfunction maybeSubscribe(entry, args) {\n  if (typeof entry.subscribe === \"function\") {\n    try {\n      maybeUnsubscribe(entry); // Prevent double subscriptions.\n\n      entry.unsubscribe = entry.subscribe.apply(null, args);\n    } catch (e) {\n      // If this Entry has a subscribe function and it threw an exception\n      // (or an unsubscribe function it previously returned now throws),\n      // return false to indicate that we were not able to subscribe (or\n      // unsubscribe), and this Entry should remain dirty.\n      entry.setDirty();\n      return false;\n    }\n  } // Returning true indicates either that there was no entry.subscribe\n  // function or that it succeeded.\n\n\n  return true;\n}\n\nvar EntryMethods = {\n  setDirty: true,\n  dispose: true,\n  forget: true\n};\n\nfunction dep(options) {\n  var depsByKey = new Map();\n  var subscribe = options && options.subscribe;\n\n  function depend(key) {\n    var parent = parentEntrySlot.getValue();\n\n    if (parent) {\n      var dep_1 = depsByKey.get(key);\n\n      if (!dep_1) {\n        depsByKey.set(key, dep_1 = new Set());\n      }\n\n      parent.dependOn(dep_1);\n\n      if (typeof subscribe === \"function\") {\n        maybeUnsubscribe(dep_1);\n        dep_1.unsubscribe = subscribe(key);\n      }\n    }\n  }\n\n  depend.dirty = function dirty(key, entryMethodName) {\n    var dep = depsByKey.get(key);\n\n    if (dep) {\n      var m_1 = entryMethodName && hasOwnProperty.call(EntryMethods, entryMethodName) ? entryMethodName : \"setDirty\"; // We have to use toArray(dep).forEach instead of dep.forEach, because\n      // modifying a Set while iterating over it can cause elements in the Set\n      // to be removed from the Set before they've been iterated over.\n\n      toArray(dep).forEach(function (entry) {\n        return entry[m_1]();\n      });\n      depsByKey.delete(key);\n      maybeUnsubscribe(dep);\n    }\n  };\n\n  return depend;\n}\n\nfunction makeDefaultMakeCacheKeyFunction() {\n  var keyTrie = new Trie(typeof WeakMap === \"function\");\n  return function () {\n    return keyTrie.lookupArray(arguments);\n  };\n} // The defaultMakeCacheKey function is remarkably powerful, because it gives\n// a unique object for any shallow-identical list of arguments. If you need\n// to implement a custom makeCacheKey function, you may find it helpful to\n// delegate the final work to defaultMakeCacheKey, which is why we export it\n// here. However, you may want to avoid defaultMakeCacheKey if your runtime\n// does not support WeakMap, or you have the ability to return a string key.\n// In those cases, just write your own custom makeCacheKey functions.\n\n\nvar defaultMakeCacheKey = makeDefaultMakeCacheKeyFunction();\nvar caches = new Set();\n\nfunction wrap(originalFunction, options) {\n  if (options === void 0) {\n    options = Object.create(null);\n  }\n\n  var cache = new Cache(options.max || Math.pow(2, 16), function (entry) {\n    return entry.dispose();\n  });\n  var keyArgs = options.keyArgs;\n  var makeCacheKey = options.makeCacheKey || makeDefaultMakeCacheKeyFunction();\n\n  var optimistic = function () {\n    var key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);\n\n    if (key === void 0) {\n      return originalFunction.apply(null, arguments);\n    }\n\n    var entry = cache.get(key);\n\n    if (!entry) {\n      cache.set(key, entry = new Entry(originalFunction));\n      entry.subscribe = options.subscribe; // Give the Entry the ability to trigger cache.delete(key), even though\n      // the Entry itself does not know about key or cache.\n\n      entry.forget = function () {\n        return cache.delete(key);\n      };\n    }\n\n    var value = entry.recompute(Array.prototype.slice.call(arguments)); // Move this entry to the front of the least-recently used queue,\n    // since we just finished computing its value.\n\n    cache.set(key, entry);\n    caches.add(cache); // Clean up any excess entries in the cache, but only if there is no\n    // active parent entry, meaning we're not in the middle of a larger\n    // computation that might be flummoxed by the cleaning.\n\n    if (!parentEntrySlot.hasValue()) {\n      caches.forEach(function (cache) {\n        return cache.clean();\n      });\n      caches.clear();\n    }\n\n    return value;\n  };\n\n  Object.defineProperty(optimistic, \"size\", {\n    get: function () {\n      return cache[\"map\"].size;\n    },\n    configurable: false,\n    enumerable: false\n  });\n\n  function dirtyKey(key) {\n    var entry = cache.get(key);\n\n    if (entry) {\n      entry.setDirty();\n    }\n  }\n\n  optimistic.dirtyKey = dirtyKey;\n\n  optimistic.dirty = function dirty() {\n    dirtyKey(makeCacheKey.apply(null, arguments));\n  };\n\n  function peekKey(key) {\n    var entry = cache.get(key);\n\n    if (entry) {\n      return entry.peek();\n    }\n  }\n\n  optimistic.peekKey = peekKey;\n\n  optimistic.peek = function peek() {\n    return peekKey(makeCacheKey.apply(null, arguments));\n  };\n\n  function forgetKey(key) {\n    return cache.delete(key);\n  }\n\n  optimistic.forgetKey = forgetKey;\n\n  optimistic.forget = function forget() {\n    return forgetKey(makeCacheKey.apply(null, arguments));\n  };\n\n  optimistic.makeCacheKey = makeCacheKey;\n  optimistic.getKey = keyArgs ? function getKey() {\n    return makeCacheKey.apply(null, keyArgs.apply(null, arguments));\n  } : makeCacheKey;\n  return Object.freeze(optimistic);\n}\n\nexport { defaultMakeCacheKey, dep, wrap };","map":{"version":3,"sources":["/home/maxi/Projects/oort/frontend/node_modules/optimism/lib/bundle.esm.js"],"names":["Trie","KeyTrie","Slot","asyncFromGen","bind","bindContext","noContext","setTimeout","defaultDispose","Cache","max","dispose","Infinity","map","Map","newest","oldest","prototype","has","key","get","node","getNode","value","older","newer","set","clean","size","delete","parentEntrySlot","_a","hasOwnProperty","Object","toArray","Array","from","collection","array","forEach","item","push","maybeUnsubscribe","entryOrDep","unsubscribe","emptySetPool","POOL_TARGET_SIZE","assert","condition","optionalMessage","Error","valueIs","a","b","len","length","valueGet","valueCopy","slice","Entry","fn","parents","Set","childValues","dirtyChildren","dirty","recomputing","deps","count","peek","mightBeDirty","rememberParent","recompute","args","reallyRecompute","setDirty","reportDirty","_this","forgetChildren","eachParent","parent","child","forgetChild","forget","dependOn","dep","add","pop","forgetDeps","clear","getValue","reportDirtyChild","reportCleanChild","entry","withValue","recomputeNewValue","maybeSubscribe","setClean","apply","e","reportClean","callback","parentCount","i","parentWasClean","childValue","removeDirtyChild","dc","_value","subscribe","EntryMethods","options","depsByKey","depend","dep_1","entryMethodName","m_1","call","makeDefaultMakeCacheKeyFunction","keyTrie","WeakMap","lookupArray","arguments","defaultMakeCacheKey","caches","wrap","originalFunction","create","cache","Math","pow","keyArgs","makeCacheKey","optimistic","hasValue","defineProperty","configurable","enumerable","dirtyKey","peekKey","forgetKey","getKey","freeze"],"mappings":"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","sourcesContent":["import { Trie } from '@wry/trie';\nexport { Trie as KeyTrie } from '@wry/trie';\nimport { Slot } from '@wry/context';\nexport { asyncFromGen, bind as bindContext, noContext, setTimeout } from '@wry/context';\n\nfunction defaultDispose() { }\r\nvar Cache = /** @class */ (function () {\r\n    function Cache(max, dispose) {\r\n        if (max === void 0) { max = Infinity; }\r\n        if (dispose === void 0) { dispose = defaultDispose; }\r\n        this.max = max;\r\n        this.dispose = dispose;\r\n        this.map = new Map();\r\n        this.newest = null;\r\n        this.oldest = null;\r\n    }\r\n    Cache.prototype.has = function (key) {\r\n        return this.map.has(key);\r\n    };\r\n    Cache.prototype.get = function (key) {\r\n        var node = this.getNode(key);\r\n        return node && node.value;\r\n    };\r\n    Cache.prototype.getNode = function (key) {\r\n        var node = this.map.get(key);\r\n        if (node && node !== this.newest) {\r\n            var older = node.older, newer = node.newer;\r\n            if (newer) {\r\n                newer.older = older;\r\n            }\r\n            if (older) {\r\n                older.newer = newer;\r\n            }\r\n            node.older = this.newest;\r\n            node.older.newer = node;\r\n            node.newer = null;\r\n            this.newest = node;\r\n            if (node === this.oldest) {\r\n                this.oldest = newer;\r\n            }\r\n        }\r\n        return node;\r\n    };\r\n    Cache.prototype.set = function (key, value) {\r\n        var node = this.getNode(key);\r\n        if (node) {\r\n            return node.value = value;\r\n        }\r\n        node = {\r\n            key: key,\r\n            value: value,\r\n            newer: null,\r\n            older: this.newest\r\n        };\r\n        if (this.newest) {\r\n            this.newest.newer = node;\r\n        }\r\n        this.newest = node;\r\n        this.oldest = this.oldest || node;\r\n        this.map.set(key, node);\r\n        return node.value;\r\n    };\r\n    Cache.prototype.clean = function () {\r\n        while (this.oldest && this.map.size > this.max) {\r\n            this.delete(this.oldest.key);\r\n        }\r\n    };\r\n    Cache.prototype.delete = function (key) {\r\n        var node = this.map.get(key);\r\n        if (node) {\r\n            if (node === this.newest) {\r\n                this.newest = node.older;\r\n            }\r\n            if (node === this.oldest) {\r\n                this.oldest = node.newer;\r\n            }\r\n            if (node.newer) {\r\n                node.newer.older = node.older;\r\n            }\r\n            if (node.older) {\r\n                node.older.newer = node.newer;\r\n            }\r\n            this.map.delete(key);\r\n            this.dispose(node.value, key);\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    return Cache;\r\n}());\n\nvar parentEntrySlot = new Slot();\n\nvar _a;\r\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\r\nvar \r\n// This Array.from polyfill is restricted to working with Set<any> for now,\r\n// but we can improve the polyfill and add other input types, as needed. Note\r\n// that this fallback implementation will only be used if the host environment\r\n// does not support a native Array.from function. In most modern JS runtimes,\r\n// the toArray function exported here will be === Array.from.\r\ntoArray = (_a = Array.from, _a === void 0 ? function (collection) {\r\n    var array = [];\r\n    collection.forEach(function (item) { return array.push(item); });\r\n    return array;\r\n} : _a);\r\nfunction maybeUnsubscribe(entryOrDep) {\r\n    var unsubscribe = entryOrDep.unsubscribe;\r\n    if (typeof unsubscribe === \"function\") {\r\n        entryOrDep.unsubscribe = void 0;\r\n        unsubscribe();\r\n    }\r\n}\n\nvar emptySetPool = [];\r\nvar POOL_TARGET_SIZE = 100;\r\n// Since this package might be used browsers, we should avoid using the\r\n// Node built-in assert module.\r\nfunction assert(condition, optionalMessage) {\r\n    if (!condition) {\r\n        throw new Error(optionalMessage || \"assertion failure\");\r\n    }\r\n}\r\nfunction valueIs(a, b) {\r\n    var len = a.length;\r\n    return (\r\n    // Unknown values are not equal to each other.\r\n    len > 0 &&\r\n        // Both values must be ordinary (or both exceptional) to be equal.\r\n        len === b.length &&\r\n        // The underlying value or exception must be the same.\r\n        a[len - 1] === b[len - 1]);\r\n}\r\nfunction valueGet(value) {\r\n    switch (value.length) {\r\n        case 0: throw new Error(\"unknown value\");\r\n        case 1: return value[0];\r\n        case 2: throw value[1];\r\n    }\r\n}\r\nfunction valueCopy(value) {\r\n    return value.slice(0);\r\n}\r\nvar Entry = /** @class */ (function () {\r\n    function Entry(fn) {\r\n        this.fn = fn;\r\n        this.parents = new Set();\r\n        this.childValues = new Map();\r\n        // When this Entry has children that are dirty, this property becomes\r\n        // a Set containing other Entry objects, borrowed from emptySetPool.\r\n        // When the set becomes empty, it gets recycled back to emptySetPool.\r\n        this.dirtyChildren = null;\r\n        this.dirty = true;\r\n        this.recomputing = false;\r\n        this.value = [];\r\n        this.deps = null;\r\n        ++Entry.count;\r\n    }\r\n    Entry.prototype.peek = function () {\r\n        if (this.value.length === 1 && !mightBeDirty(this)) {\r\n            rememberParent(this);\r\n            return this.value[0];\r\n        }\r\n    };\r\n    // This is the most important method of the Entry API, because it\r\n    // determines whether the cached this.value can be returned immediately,\r\n    // or must be recomputed. The overall performance of the caching system\r\n    // depends on the truth of the following observations: (1) this.dirty is\r\n    // usually false, (2) this.dirtyChildren is usually null/empty, and thus\r\n    // (3) valueGet(this.value) is usually returned without recomputation.\r\n    Entry.prototype.recompute = function (args) {\r\n        assert(!this.recomputing, \"already recomputing\");\r\n        rememberParent(this);\r\n        return mightBeDirty(this)\r\n            ? reallyRecompute(this, args)\r\n            : valueGet(this.value);\r\n    };\r\n    Entry.prototype.setDirty = function () {\r\n        if (this.dirty)\r\n            return;\r\n        this.dirty = true;\r\n        this.value.length = 0;\r\n        reportDirty(this);\r\n        // We can go ahead and unsubscribe here, since any further dirty\r\n        // notifications we receive will be redundant, and unsubscribing may\r\n        // free up some resources, e.g. file watchers.\r\n        maybeUnsubscribe(this);\r\n    };\r\n    Entry.prototype.dispose = function () {\r\n        var _this = this;\r\n        this.setDirty();\r\n        // Sever any dependency relationships with our own children, so those\r\n        // children don't retain this parent Entry in their child.parents sets,\r\n        // thereby preventing it from being fully garbage collected.\r\n        forgetChildren(this);\r\n        // Because this entry has been kicked out of the cache (in index.js),\r\n        // we've lost the ability to find out if/when this entry becomes dirty,\r\n        // whether that happens through a subscription, because of a direct call\r\n        // to entry.setDirty(), or because one of its children becomes dirty.\r\n        // Because of this loss of future information, we have to assume the\r\n        // worst (that this entry might have become dirty very soon), so we must\r\n        // immediately mark this entry's parents as dirty. Normally we could\r\n        // just call entry.setDirty() rather than calling parent.setDirty() for\r\n        // each parent, but that would leave this entry in parent.childValues\r\n        // and parent.dirtyChildren, which would prevent the child from being\r\n        // truly forgotten.\r\n        eachParent(this, function (parent, child) {\r\n            parent.setDirty();\r\n            forgetChild(parent, _this);\r\n        });\r\n    };\r\n    Entry.prototype.forget = function () {\r\n        // The code that creates Entry objects in index.ts will replace this method\r\n        // with one that actually removes the Entry from the cache, which will also\r\n        // trigger the entry.dispose method.\r\n        this.dispose();\r\n    };\r\n    Entry.prototype.dependOn = function (dep) {\r\n        dep.add(this);\r\n        if (!this.deps) {\r\n            this.deps = emptySetPool.pop() || new Set();\r\n        }\r\n        this.deps.add(dep);\r\n    };\r\n    Entry.prototype.forgetDeps = function () {\r\n        var _this = this;\r\n        if (this.deps) {\r\n            toArray(this.deps).forEach(function (dep) { return dep.delete(_this); });\r\n            this.deps.clear();\r\n            emptySetPool.push(this.deps);\r\n            this.deps = null;\r\n        }\r\n    };\r\n    Entry.count = 0;\r\n    return Entry;\r\n}());\r\nfunction rememberParent(child) {\r\n    var parent = parentEntrySlot.getValue();\r\n    if (parent) {\r\n        child.parents.add(parent);\r\n        if (!parent.childValues.has(child)) {\r\n            parent.childValues.set(child, []);\r\n        }\r\n        if (mightBeDirty(child)) {\r\n            reportDirtyChild(parent, child);\r\n        }\r\n        else {\r\n            reportCleanChild(parent, child);\r\n        }\r\n        return parent;\r\n    }\r\n}\r\nfunction reallyRecompute(entry, args) {\r\n    forgetChildren(entry);\r\n    // Set entry as the parent entry while calling recomputeNewValue(entry).\r\n    parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);\r\n    if (maybeSubscribe(entry, args)) {\r\n        // If we successfully recomputed entry.value and did not fail to\r\n        // (re)subscribe, then this Entry is no longer explicitly dirty.\r\n        setClean(entry);\r\n    }\r\n    return valueGet(entry.value);\r\n}\r\nfunction recomputeNewValue(entry, args) {\r\n    entry.recomputing = true;\r\n    // Set entry.value as unknown.\r\n    entry.value.length = 0;\r\n    try {\r\n        // If entry.fn succeeds, entry.value will become a normal Value.\r\n        entry.value[0] = entry.fn.apply(null, args);\r\n    }\r\n    catch (e) {\r\n        // If entry.fn throws, entry.value will become exceptional.\r\n        entry.value[1] = e;\r\n    }\r\n    // Either way, this line is always reached.\r\n    entry.recomputing = false;\r\n}\r\nfunction mightBeDirty(entry) {\r\n    return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);\r\n}\r\nfunction setClean(entry) {\r\n    entry.dirty = false;\r\n    if (mightBeDirty(entry)) {\r\n        // This Entry may still have dirty children, in which case we can't\r\n        // let our parents know we're clean just yet.\r\n        return;\r\n    }\r\n    reportClean(entry);\r\n}\r\nfunction reportDirty(child) {\r\n    eachParent(child, reportDirtyChild);\r\n}\r\nfunction reportClean(child) {\r\n    eachParent(child, reportCleanChild);\r\n}\r\nfunction eachParent(child, callback) {\r\n    var parentCount = child.parents.size;\r\n    if (parentCount) {\r\n        var parents = toArray(child.parents);\r\n        for (var i = 0; i < parentCount; ++i) {\r\n            callback(parents[i], child);\r\n        }\r\n    }\r\n}\r\n// Let a parent Entry know that one of its children may be dirty.\r\nfunction reportDirtyChild(parent, child) {\r\n    // Must have called rememberParent(child) before calling\r\n    // reportDirtyChild(parent, child).\r\n    assert(parent.childValues.has(child));\r\n    assert(mightBeDirty(child));\r\n    var parentWasClean = !mightBeDirty(parent);\r\n    if (!parent.dirtyChildren) {\r\n        parent.dirtyChildren = emptySetPool.pop() || new Set;\r\n    }\r\n    else if (parent.dirtyChildren.has(child)) {\r\n        // If we already know this child is dirty, then we must have already\r\n        // informed our own parents that we are dirty, so we can terminate\r\n        // the recursion early.\r\n        return;\r\n    }\r\n    parent.dirtyChildren.add(child);\r\n    // If parent was clean before, it just became (possibly) dirty (according to\r\n    // mightBeDirty), since we just added child to parent.dirtyChildren.\r\n    if (parentWasClean) {\r\n        reportDirty(parent);\r\n    }\r\n}\r\n// Let a parent Entry know that one of its children is no longer dirty.\r\nfunction reportCleanChild(parent, child) {\r\n    // Must have called rememberChild(child) before calling\r\n    // reportCleanChild(parent, child).\r\n    assert(parent.childValues.has(child));\r\n    assert(!mightBeDirty(child));\r\n    var childValue = parent.childValues.get(child);\r\n    if (childValue.length === 0) {\r\n        parent.childValues.set(child, valueCopy(child.value));\r\n    }\r\n    else if (!valueIs(childValue, child.value)) {\r\n        parent.setDirty();\r\n    }\r\n    removeDirtyChild(parent, child);\r\n    if (mightBeDirty(parent)) {\r\n        return;\r\n    }\r\n    reportClean(parent);\r\n}\r\nfunction removeDirtyChild(parent, child) {\r\n    var dc = parent.dirtyChildren;\r\n    if (dc) {\r\n        dc.delete(child);\r\n        if (dc.size === 0) {\r\n            if (emptySetPool.length < POOL_TARGET_SIZE) {\r\n                emptySetPool.push(dc);\r\n            }\r\n            parent.dirtyChildren = null;\r\n        }\r\n    }\r\n}\r\n// Removes all children from this entry and returns an array of the\r\n// removed children.\r\nfunction forgetChildren(parent) {\r\n    if (parent.childValues.size > 0) {\r\n        parent.childValues.forEach(function (_value, child) {\r\n            forgetChild(parent, child);\r\n        });\r\n    }\r\n    // Remove this parent Entry from any sets to which it was added by the\r\n    // addToSet method.\r\n    parent.forgetDeps();\r\n    // After we forget all our children, this.dirtyChildren must be empty\r\n    // and therefore must have been reset to null.\r\n    assert(parent.dirtyChildren === null);\r\n}\r\nfunction forgetChild(parent, child) {\r\n    child.parents.delete(parent);\r\n    parent.childValues.delete(child);\r\n    removeDirtyChild(parent, child);\r\n}\r\nfunction maybeSubscribe(entry, args) {\r\n    if (typeof entry.subscribe === \"function\") {\r\n        try {\r\n            maybeUnsubscribe(entry); // Prevent double subscriptions.\r\n            entry.unsubscribe = entry.subscribe.apply(null, args);\r\n        }\r\n        catch (e) {\r\n            // If this Entry has a subscribe function and it threw an exception\r\n            // (or an unsubscribe function it previously returned now throws),\r\n            // return false to indicate that we were not able to subscribe (or\r\n            // unsubscribe), and this Entry should remain dirty.\r\n            entry.setDirty();\r\n            return false;\r\n        }\r\n    }\r\n    // Returning true indicates either that there was no entry.subscribe\r\n    // function or that it succeeded.\r\n    return true;\r\n}\n\nvar EntryMethods = {\r\n    setDirty: true,\r\n    dispose: true,\r\n    forget: true,\r\n};\r\nfunction dep(options) {\r\n    var depsByKey = new Map();\r\n    var subscribe = options && options.subscribe;\r\n    function depend(key) {\r\n        var parent = parentEntrySlot.getValue();\r\n        if (parent) {\r\n            var dep_1 = depsByKey.get(key);\r\n            if (!dep_1) {\r\n                depsByKey.set(key, dep_1 = new Set);\r\n            }\r\n            parent.dependOn(dep_1);\r\n            if (typeof subscribe === \"function\") {\r\n                maybeUnsubscribe(dep_1);\r\n                dep_1.unsubscribe = subscribe(key);\r\n            }\r\n        }\r\n    }\r\n    depend.dirty = function dirty(key, entryMethodName) {\r\n        var dep = depsByKey.get(key);\r\n        if (dep) {\r\n            var m_1 = (entryMethodName &&\r\n                hasOwnProperty.call(EntryMethods, entryMethodName)) ? entryMethodName : \"setDirty\";\r\n            // We have to use toArray(dep).forEach instead of dep.forEach, because\r\n            // modifying a Set while iterating over it can cause elements in the Set\r\n            // to be removed from the Set before they've been iterated over.\r\n            toArray(dep).forEach(function (entry) { return entry[m_1](); });\r\n            depsByKey.delete(key);\r\n            maybeUnsubscribe(dep);\r\n        }\r\n    };\r\n    return depend;\r\n}\n\nfunction makeDefaultMakeCacheKeyFunction() {\r\n    var keyTrie = new Trie(typeof WeakMap === \"function\");\r\n    return function () {\r\n        return keyTrie.lookupArray(arguments);\r\n    };\r\n}\r\n// The defaultMakeCacheKey function is remarkably powerful, because it gives\r\n// a unique object for any shallow-identical list of arguments. If you need\r\n// to implement a custom makeCacheKey function, you may find it helpful to\r\n// delegate the final work to defaultMakeCacheKey, which is why we export it\r\n// here. However, you may want to avoid defaultMakeCacheKey if your runtime\r\n// does not support WeakMap, or you have the ability to return a string key.\r\n// In those cases, just write your own custom makeCacheKey functions.\r\nvar defaultMakeCacheKey = makeDefaultMakeCacheKeyFunction();\r\nvar caches = new Set();\r\nfunction wrap(originalFunction, options) {\r\n    if (options === void 0) { options = Object.create(null); }\r\n    var cache = new Cache(options.max || Math.pow(2, 16), function (entry) { return entry.dispose(); });\r\n    var keyArgs = options.keyArgs;\r\n    var makeCacheKey = options.makeCacheKey ||\r\n        makeDefaultMakeCacheKeyFunction();\r\n    var optimistic = function () {\r\n        var key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);\r\n        if (key === void 0) {\r\n            return originalFunction.apply(null, arguments);\r\n        }\r\n        var entry = cache.get(key);\r\n        if (!entry) {\r\n            cache.set(key, entry = new Entry(originalFunction));\r\n            entry.subscribe = options.subscribe;\r\n            // Give the Entry the ability to trigger cache.delete(key), even though\r\n            // the Entry itself does not know about key or cache.\r\n            entry.forget = function () { return cache.delete(key); };\r\n        }\r\n        var value = entry.recompute(Array.prototype.slice.call(arguments));\r\n        // Move this entry to the front of the least-recently used queue,\r\n        // since we just finished computing its value.\r\n        cache.set(key, entry);\r\n        caches.add(cache);\r\n        // Clean up any excess entries in the cache, but only if there is no\r\n        // active parent entry, meaning we're not in the middle of a larger\r\n        // computation that might be flummoxed by the cleaning.\r\n        if (!parentEntrySlot.hasValue()) {\r\n            caches.forEach(function (cache) { return cache.clean(); });\r\n            caches.clear();\r\n        }\r\n        return value;\r\n    };\r\n    Object.defineProperty(optimistic, \"size\", {\r\n        get: function () {\r\n            return cache[\"map\"].size;\r\n        },\r\n        configurable: false,\r\n        enumerable: false,\r\n    });\r\n    function dirtyKey(key) {\r\n        var entry = cache.get(key);\r\n        if (entry) {\r\n            entry.setDirty();\r\n        }\r\n    }\r\n    optimistic.dirtyKey = dirtyKey;\r\n    optimistic.dirty = function dirty() {\r\n        dirtyKey(makeCacheKey.apply(null, arguments));\r\n    };\r\n    function peekKey(key) {\r\n        var entry = cache.get(key);\r\n        if (entry) {\r\n            return entry.peek();\r\n        }\r\n    }\r\n    optimistic.peekKey = peekKey;\r\n    optimistic.peek = function peek() {\r\n        return peekKey(makeCacheKey.apply(null, arguments));\r\n    };\r\n    function forgetKey(key) {\r\n        return cache.delete(key);\r\n    }\r\n    optimistic.forgetKey = forgetKey;\r\n    optimistic.forget = function forget() {\r\n        return forgetKey(makeCacheKey.apply(null, arguments));\r\n    };\r\n    optimistic.makeCacheKey = makeCacheKey;\r\n    optimistic.getKey = keyArgs ? function getKey() {\r\n        return makeCacheKey.apply(null, keyArgs.apply(null, arguments));\r\n    } : makeCacheKey;\r\n    return Object.freeze(optimistic);\r\n}\n\nexport { defaultMakeCacheKey, dep, wrap };\n"]},"metadata":{},"sourceType":"module"}