{"ast":null,"code":"// This currentContext variable will only be used if the makeSlotClass\n// function is called, which happens only if this is the first copy of the\n// @wry/context package to be imported.\nvar currentContext = null; // This unique internal object is used to denote the absence of a value\n// for a given Slot, and is never exposed to outside code.\n\nvar MISSING_VALUE = {};\nvar idCounter = 1; // Although we can't do anything about the cost of duplicated code from\n// accidentally bundling multiple copies of the @wry/context package, we can\n// avoid creating the Slot class more than once using makeSlotClass.\n\nvar makeSlotClass = function () {\n  return (\n    /** @class */\n    function () {\n      function Slot() {\n        // If you have a Slot object, you can find out its slot.id, but you cannot\n        // guess the slot.id of a Slot you don't have access to, thanks to the\n        // randomized suffix.\n        this.id = [\"slot\", idCounter++, Date.now(), Math.random().toString(36).slice(2)].join(\":\");\n      }\n\n      Slot.prototype.hasValue = function () {\n        for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {\n          // We use the Slot object iself as a key to its value, which means the\n          // value cannot be obtained without a reference to the Slot object.\n          if (this.id in context_1.slots) {\n            var value = context_1.slots[this.id];\n            if (value === MISSING_VALUE) break;\n\n            if (context_1 !== currentContext) {\n              // Cache the value in currentContext.slots so the next lookup will\n              // be faster. This caching is safe because the tree of contexts and\n              // the values of the slots are logically immutable.\n              currentContext.slots[this.id] = value;\n            }\n\n            return true;\n          }\n        }\n\n        if (currentContext) {\n          // If a value was not found for this Slot, it's never going to be found\n          // no matter how many times we look it up, so we might as well cache\n          // the absence of the value, too.\n          currentContext.slots[this.id] = MISSING_VALUE;\n        }\n\n        return false;\n      };\n\n      Slot.prototype.getValue = function () {\n        if (this.hasValue()) {\n          return currentContext.slots[this.id];\n        }\n      };\n\n      Slot.prototype.withValue = function (value, callback, // Given the prevalence of arrow functions, specifying arguments is likely\n      // to be much more common than specifying `this`, hence this ordering:\n      args, thisArg) {\n        var _a;\n\n        var slots = (_a = {\n          __proto__: null\n        }, _a[this.id] = value, _a);\n        var parent = currentContext;\n        currentContext = {\n          parent: parent,\n          slots: slots\n        };\n\n        try {\n          // Function.prototype.apply allows the arguments array argument to be\n          // omitted or undefined, so args! is fine here.\n          return callback.apply(thisArg, args);\n        } finally {\n          currentContext = parent;\n        }\n      }; // Capture the current context and wrap a callback function so that it\n      // reestablishes the captured context when called.\n\n\n      Slot.bind = function (callback) {\n        var context = currentContext;\n        return function () {\n          var saved = currentContext;\n\n          try {\n            currentContext = context;\n            return callback.apply(this, arguments);\n          } finally {\n            currentContext = saved;\n          }\n        };\n      }; // Immediately run a callback function without any captured context.\n\n\n      Slot.noContext = function (callback, // Given the prevalence of arrow functions, specifying arguments is likely\n      // to be much more common than specifying `this`, hence this ordering:\n      args, thisArg) {\n        if (currentContext) {\n          var saved = currentContext;\n\n          try {\n            currentContext = null; // Function.prototype.apply allows the arguments array argument to be\n            // omitted or undefined, so args! is fine here.\n\n            return callback.apply(thisArg, args);\n          } finally {\n            currentContext = saved;\n          }\n        } else {\n          return callback.apply(thisArg, args);\n        }\n      };\n\n      return Slot;\n    }()\n  );\n}; // We store a single global implementation of the Slot class as a permanent\n// non-enumerable symbol property of the Array constructor. This obfuscation\n// does nothing to prevent access to the Slot class, but at least it ensures\n// the implementation (i.e. currentContext) cannot be tampered with, and all\n// copies of the @wry/context package (hopefully just one) will share the\n// same Slot implementation. Since the first copy of the @wry/context package\n// to be imported wins, this technique imposes a very high cost for any\n// future breaking changes to the Slot class.\n\n\nvar globalKey = \"@wry/context:Slot\";\nvar host = Array;\n\nvar Slot = host[globalKey] || function () {\n  var Slot = makeSlotClass();\n\n  try {\n    Object.defineProperty(host, globalKey, {\n      value: host[globalKey] = Slot,\n      enumerable: false,\n      writable: false,\n      configurable: false\n    });\n  } finally {\n    return Slot;\n  }\n}();\n\nvar bind = Slot.bind,\n    noContext = Slot.noContext;\n\nfunction setTimeoutWithContext(callback, delay) {\n  return setTimeout(bind(callback), delay);\n} // Turn any generator function into an async function (using yield instead\n// of await), with context automatically preserved across yields.\n\n\nfunction asyncFromGen(genFn) {\n  return function () {\n    var gen = genFn.apply(this, arguments);\n    var boundNext = bind(gen.next);\n    var boundThrow = bind(gen.throw);\n    return new Promise(function (resolve, reject) {\n      function invoke(method, argument) {\n        try {\n          var result = method.call(gen, argument);\n        } catch (error) {\n          return reject(error);\n        }\n\n        var next = result.done ? resolve : invokeNext;\n\n        if (isPromiseLike(result.value)) {\n          result.value.then(next, result.done ? reject : invokeThrow);\n        } else {\n          next(result.value);\n        }\n      }\n\n      var invokeNext = function (value) {\n        return invoke(boundNext, value);\n      };\n\n      var invokeThrow = function (error) {\n        return invoke(boundThrow, error);\n      };\n\n      invokeNext();\n    });\n  };\n}\n\nfunction isPromiseLike(value) {\n  return value && typeof value.then === \"function\";\n} // If you use the fibers npm package to implement coroutines in Node.js,\n// you should call this function at least once to ensure context management\n// remains coherent across any yields.\n\n\nvar wrappedFibers = [];\n\nfunction wrapYieldingFiberMethods(Fiber) {\n  // There can be only one implementation of Fiber per process, so this array\n  // should never grow longer than one element.\n  if (wrappedFibers.indexOf(Fiber) < 0) {\n    var wrap = function (obj, method) {\n      var fn = obj[method];\n\n      obj[method] = function () {\n        return noContext(fn, arguments, this);\n      };\n    }; // These methods can yield, according to\n    // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\n\n\n    wrap(Fiber, \"yield\");\n    wrap(Fiber.prototype, \"run\");\n    wrap(Fiber.prototype, \"throwInto\");\n    wrappedFibers.push(Fiber);\n  }\n\n  return Fiber;\n}\n\nexport { Slot, asyncFromGen, bind, noContext, setTimeoutWithContext as setTimeout, wrapYieldingFiberMethods };","map":{"version":3,"sources":["/home/maxi/Projects/oort/frontend/node_modules/@wry/context/lib/context.esm.js"],"names":["currentContext","MISSING_VALUE","idCounter","makeSlotClass","Slot","id","Date","now","Math","random","toString","slice","join","prototype","hasValue","context_1","parent","slots","value","getValue","withValue","callback","args","thisArg","_a","__proto__","apply","bind","context","saved","arguments","noContext","globalKey","host","Array","Object","defineProperty","enumerable","writable","configurable","setTimeoutWithContext","delay","setTimeout","asyncFromGen","genFn","gen","boundNext","next","boundThrow","throw","Promise","resolve","reject","invoke","method","argument","result","call","error","done","invokeNext","isPromiseLike","then","invokeThrow","wrappedFibers","wrapYieldingFiberMethods","Fiber","indexOf","wrap","obj","fn","push"],"mappings":"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","sourcesContent":["// This currentContext variable will only be used if the makeSlotClass\r\n// function is called, which happens only if this is the first copy of the\r\n// @wry/context package to be imported.\r\nvar currentContext = null;\r\n// This unique internal object is used to denote the absence of a value\r\n// for a given Slot, and is never exposed to outside code.\r\nvar MISSING_VALUE = {};\r\nvar idCounter = 1;\r\n// Although we can't do anything about the cost of duplicated code from\r\n// accidentally bundling multiple copies of the @wry/context package, we can\r\n// avoid creating the Slot class more than once using makeSlotClass.\r\nvar makeSlotClass = function () { return /** @class */ (function () {\r\n    function Slot() {\r\n        // If you have a Slot object, you can find out its slot.id, but you cannot\r\n        // guess the slot.id of a Slot you don't have access to, thanks to the\r\n        // randomized suffix.\r\n        this.id = [\r\n            \"slot\",\r\n            idCounter++,\r\n            Date.now(),\r\n            Math.random().toString(36).slice(2),\r\n        ].join(\":\");\r\n    }\r\n    Slot.prototype.hasValue = function () {\r\n        for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {\r\n            // We use the Slot object iself as a key to its value, which means the\r\n            // value cannot be obtained without a reference to the Slot object.\r\n            if (this.id in context_1.slots) {\r\n                var value = context_1.slots[this.id];\r\n                if (value === MISSING_VALUE)\r\n                    break;\r\n                if (context_1 !== currentContext) {\r\n                    // Cache the value in currentContext.slots so the next lookup will\r\n                    // be faster. This caching is safe because the tree of contexts and\r\n                    // the values of the slots are logically immutable.\r\n                    currentContext.slots[this.id] = value;\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        if (currentContext) {\r\n            // If a value was not found for this Slot, it's never going to be found\r\n            // no matter how many times we look it up, so we might as well cache\r\n            // the absence of the value, too.\r\n            currentContext.slots[this.id] = MISSING_VALUE;\r\n        }\r\n        return false;\r\n    };\r\n    Slot.prototype.getValue = function () {\r\n        if (this.hasValue()) {\r\n            return currentContext.slots[this.id];\r\n        }\r\n    };\r\n    Slot.prototype.withValue = function (value, callback, \r\n    // Given the prevalence of arrow functions, specifying arguments is likely\r\n    // to be much more common than specifying `this`, hence this ordering:\r\n    args, thisArg) {\r\n        var _a;\r\n        var slots = (_a = {\r\n                __proto__: null\r\n            },\r\n            _a[this.id] = value,\r\n            _a);\r\n        var parent = currentContext;\r\n        currentContext = { parent: parent, slots: slots };\r\n        try {\r\n            // Function.prototype.apply allows the arguments array argument to be\r\n            // omitted or undefined, so args! is fine here.\r\n            return callback.apply(thisArg, args);\r\n        }\r\n        finally {\r\n            currentContext = parent;\r\n        }\r\n    };\r\n    // Capture the current context and wrap a callback function so that it\r\n    // reestablishes the captured context when called.\r\n    Slot.bind = function (callback) {\r\n        var context = currentContext;\r\n        return function () {\r\n            var saved = currentContext;\r\n            try {\r\n                currentContext = context;\r\n                return callback.apply(this, arguments);\r\n            }\r\n            finally {\r\n                currentContext = saved;\r\n            }\r\n        };\r\n    };\r\n    // Immediately run a callback function without any captured context.\r\n    Slot.noContext = function (callback, \r\n    // Given the prevalence of arrow functions, specifying arguments is likely\r\n    // to be much more common than specifying `this`, hence this ordering:\r\n    args, thisArg) {\r\n        if (currentContext) {\r\n            var saved = currentContext;\r\n            try {\r\n                currentContext = null;\r\n                // Function.prototype.apply allows the arguments array argument to be\r\n                // omitted or undefined, so args! is fine here.\r\n                return callback.apply(thisArg, args);\r\n            }\r\n            finally {\r\n                currentContext = saved;\r\n            }\r\n        }\r\n        else {\r\n            return callback.apply(thisArg, args);\r\n        }\r\n    };\r\n    return Slot;\r\n}()); };\r\n// We store a single global implementation of the Slot class as a permanent\r\n// non-enumerable symbol property of the Array constructor. This obfuscation\r\n// does nothing to prevent access to the Slot class, but at least it ensures\r\n// the implementation (i.e. currentContext) cannot be tampered with, and all\r\n// copies of the @wry/context package (hopefully just one) will share the\r\n// same Slot implementation. Since the first copy of the @wry/context package\r\n// to be imported wins, this technique imposes a very high cost for any\r\n// future breaking changes to the Slot class.\r\nvar globalKey = \"@wry/context:Slot\";\r\nvar host = Array;\r\nvar Slot = host[globalKey] || function () {\r\n    var Slot = makeSlotClass();\r\n    try {\r\n        Object.defineProperty(host, globalKey, {\r\n            value: host[globalKey] = Slot,\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: false,\r\n        });\r\n    }\r\n    finally {\r\n        return Slot;\r\n    }\r\n}();\n\nvar bind = Slot.bind, noContext = Slot.noContext;\r\nfunction setTimeoutWithContext(callback, delay) {\r\n    return setTimeout(bind(callback), delay);\r\n}\r\n// Turn any generator function into an async function (using yield instead\r\n// of await), with context automatically preserved across yields.\r\nfunction asyncFromGen(genFn) {\r\n    return function () {\r\n        var gen = genFn.apply(this, arguments);\r\n        var boundNext = bind(gen.next);\r\n        var boundThrow = bind(gen.throw);\r\n        return new Promise(function (resolve, reject) {\r\n            function invoke(method, argument) {\r\n                try {\r\n                    var result = method.call(gen, argument);\r\n                }\r\n                catch (error) {\r\n                    return reject(error);\r\n                }\r\n                var next = result.done ? resolve : invokeNext;\r\n                if (isPromiseLike(result.value)) {\r\n                    result.value.then(next, result.done ? reject : invokeThrow);\r\n                }\r\n                else {\r\n                    next(result.value);\r\n                }\r\n            }\r\n            var invokeNext = function (value) { return invoke(boundNext, value); };\r\n            var invokeThrow = function (error) { return invoke(boundThrow, error); };\r\n            invokeNext();\r\n        });\r\n    };\r\n}\r\nfunction isPromiseLike(value) {\r\n    return value && typeof value.then === \"function\";\r\n}\r\n// If you use the fibers npm package to implement coroutines in Node.js,\r\n// you should call this function at least once to ensure context management\r\n// remains coherent across any yields.\r\nvar wrappedFibers = [];\r\nfunction wrapYieldingFiberMethods(Fiber) {\r\n    // There can be only one implementation of Fiber per process, so this array\r\n    // should never grow longer than one element.\r\n    if (wrappedFibers.indexOf(Fiber) < 0) {\r\n        var wrap = function (obj, method) {\r\n            var fn = obj[method];\r\n            obj[method] = function () {\r\n                return noContext(fn, arguments, this);\r\n            };\r\n        };\r\n        // These methods can yield, according to\r\n        // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\r\n        wrap(Fiber, \"yield\");\r\n        wrap(Fiber.prototype, \"run\");\r\n        wrap(Fiber.prototype, \"throwInto\");\r\n        wrappedFibers.push(Fiber);\r\n    }\r\n    return Fiber;\r\n}\n\nexport { Slot, asyncFromGen, bind, noContext, setTimeoutWithContext as setTimeout, wrapYieldingFiberMethods };\n"]},"metadata":{},"sourceType":"module"}