{"ast":null,"code":"import { Observable } from \"./Observable.js\";\nexport function asyncMap(observable, mapFn, catchFn) {\n  return new Observable(function (observer) {\n    var next = observer.next,\n        error = observer.error,\n        complete = observer.complete;\n    var activeCallbackCount = 0;\n    var completed = false;\n    var promiseQueue = {\n      then: function (callback) {\n        return new Promise(function (resolve) {\n          return resolve(callback());\n        });\n      }\n    };\n\n    function makeCallback(examiner, delegate) {\n      if (examiner) {\n        return function (arg) {\n          ++activeCallbackCount;\n\n          var both = function () {\n            return examiner(arg);\n          };\n\n          promiseQueue = promiseQueue.then(both, both).then(function (result) {\n            --activeCallbackCount;\n            next && next.call(observer, result);\n\n            if (completed) {\n              handler.complete();\n            }\n          }, function (error) {\n            --activeCallbackCount;\n            throw error;\n          }).catch(function (caught) {\n            error && error.call(observer, caught);\n          });\n        };\n      } else {\n        return function (arg) {\n          return delegate && delegate.call(observer, arg);\n        };\n      }\n    }\n\n    var handler = {\n      next: makeCallback(mapFn, next),\n      error: makeCallback(catchFn, error),\n      complete: function () {\n        completed = true;\n\n        if (!activeCallbackCount) {\n          complete && complete.call(observer);\n        }\n      }\n    };\n    var sub = observable.subscribe(handler);\n    return function () {\n      return sub.unsubscribe();\n    };\n  });\n}","map":{"version":3,"sources":["/home/maxi/Projects/oort/frontend/node_modules/@apollo/client/utilities/observables/asyncMap.js"],"names":["Observable","asyncMap","observable","mapFn","catchFn","observer","next","error","complete","activeCallbackCount","completed","promiseQueue","then","callback","Promise","resolve","makeCallback","examiner","delegate","arg","both","result","call","handler","catch","caught","sub","subscribe","unsubscribe"],"mappings":"AAAA,SAASA,UAAT,QAA2B,iBAA3B;AACA,OAAO,SAASC,QAAT,CAAkBC,UAAlB,EAA8BC,KAA9B,EAAqCC,OAArC,EAA8C;AACjD,SAAO,IAAIJ,UAAJ,CAAe,UAAUK,QAAV,EAAoB;AACtC,QAAIC,IAAI,GAAGD,QAAQ,CAACC,IAApB;AAAA,QAA0BC,KAAK,GAAGF,QAAQ,CAACE,KAA3C;AAAA,QAAkDC,QAAQ,GAAGH,QAAQ,CAACG,QAAtE;AACA,QAAIC,mBAAmB,GAAG,CAA1B;AACA,QAAIC,SAAS,GAAG,KAAhB;AACA,QAAIC,YAAY,GAAG;AACfC,MAAAA,IAAI,EAAE,UAAUC,QAAV,EAAoB;AACtB,eAAO,IAAIC,OAAJ,CAAY,UAAUC,OAAV,EAAmB;AAAE,iBAAOA,OAAO,CAACF,QAAQ,EAAT,CAAd;AAA6B,SAA9D,CAAP;AACH;AAHc,KAAnB;;AAKA,aAASG,YAAT,CAAsBC,QAAtB,EAAgCC,QAAhC,EAA0C;AACtC,UAAID,QAAJ,EAAc;AACV,eAAO,UAAUE,GAAV,EAAe;AAClB,YAAEV,mBAAF;;AACA,cAAIW,IAAI,GAAG,YAAY;AAAE,mBAAOH,QAAQ,CAACE,GAAD,CAAf;AAAuB,WAAhD;;AACAR,UAAAA,YAAY,GAAGA,YAAY,CAACC,IAAb,CAAkBQ,IAAlB,EAAwBA,IAAxB,EAA8BR,IAA9B,CAAmC,UAAUS,MAAV,EAAkB;AAChE,cAAEZ,mBAAF;AACAH,YAAAA,IAAI,IAAIA,IAAI,CAACgB,IAAL,CAAUjB,QAAV,EAAoBgB,MAApB,CAAR;;AACA,gBAAIX,SAAJ,EAAe;AACXa,cAAAA,OAAO,CAACf,QAAR;AACH;AACJ,WANc,EAMZ,UAAUD,KAAV,EAAiB;AAChB,cAAEE,mBAAF;AACA,kBAAMF,KAAN;AACH,WATc,EASZiB,KATY,CASN,UAAUC,MAAV,EAAkB;AACvBlB,YAAAA,KAAK,IAAIA,KAAK,CAACe,IAAN,CAAWjB,QAAX,EAAqBoB,MAArB,CAAT;AACH,WAXc,CAAf;AAYH,SAfD;AAgBH,OAjBD,MAkBK;AACD,eAAO,UAAUN,GAAV,EAAe;AAAE,iBAAOD,QAAQ,IAAIA,QAAQ,CAACI,IAAT,CAAcjB,QAAd,EAAwBc,GAAxB,CAAnB;AAAkD,SAA1E;AACH;AACJ;;AACD,QAAII,OAAO,GAAG;AACVjB,MAAAA,IAAI,EAAEU,YAAY,CAACb,KAAD,EAAQG,IAAR,CADR;AAEVC,MAAAA,KAAK,EAAES,YAAY,CAACZ,OAAD,EAAUG,KAAV,CAFT;AAGVC,MAAAA,QAAQ,EAAE,YAAY;AAClBE,QAAAA,SAAS,GAAG,IAAZ;;AACA,YAAI,CAACD,mBAAL,EAA0B;AACtBD,UAAAA,QAAQ,IAAIA,QAAQ,CAACc,IAAT,CAAcjB,QAAd,CAAZ;AACH;AACJ;AARS,KAAd;AAUA,QAAIqB,GAAG,GAAGxB,UAAU,CAACyB,SAAX,CAAqBJ,OAArB,CAAV;AACA,WAAO,YAAY;AAAE,aAAOG,GAAG,CAACE,WAAJ,EAAP;AAA2B,KAAhD;AACH,GA5CM,CAAP;AA6CH","sourcesContent":["import { Observable } from \"./Observable.js\";\nexport function asyncMap(observable, mapFn, catchFn) {\n    return new Observable(function (observer) {\n        var next = observer.next, error = observer.error, complete = observer.complete;\n        var activeCallbackCount = 0;\n        var completed = false;\n        var promiseQueue = {\n            then: function (callback) {\n                return new Promise(function (resolve) { return resolve(callback()); });\n            },\n        };\n        function makeCallback(examiner, delegate) {\n            if (examiner) {\n                return function (arg) {\n                    ++activeCallbackCount;\n                    var both = function () { return examiner(arg); };\n                    promiseQueue = promiseQueue.then(both, both).then(function (result) {\n                        --activeCallbackCount;\n                        next && next.call(observer, result);\n                        if (completed) {\n                            handler.complete();\n                        }\n                    }, function (error) {\n                        --activeCallbackCount;\n                        throw error;\n                    }).catch(function (caught) {\n                        error && error.call(observer, caught);\n                    });\n                };\n            }\n            else {\n                return function (arg) { return delegate && delegate.call(observer, arg); };\n            }\n        }\n        var handler = {\n            next: makeCallback(mapFn, next),\n            error: makeCallback(catchFn, error),\n            complete: function () {\n                completed = true;\n                if (!activeCallbackCount) {\n                    complete && complete.call(observer);\n                }\n            },\n        };\n        var sub = observable.subscribe(handler);\n        return function () { return sub.unsubscribe(); };\n    });\n}\n"]},"metadata":{},"sourceType":"module"}